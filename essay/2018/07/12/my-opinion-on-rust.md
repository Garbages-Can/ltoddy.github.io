# 时下我对rust的一些见解

*我写的rust代码，已经在很多用户的电脑中运行了。*

-------------------------------------------------------

我与2018年年初，由于工作原因，开始使用rust在公司编写程序，当时只是为了完成任务，基本都是抄文档然后改。
没有仔细的 **“思考”** rust.

```rust
let a = ...;
let mut b = ...;
```

很多人会把这当做是定义变量，然后赋值。这是错误的，rust中随处可见模式匹配于结构，这两行代码是pattern destructure。

rust并没有什么真正“强”之初，只不过是你的程序为编译器提供了大量的信息，让rust可以在编译期做大量的事情(可以简单的视为，他把你把程序先跑了一遍)，以此来实现所谓的“安全”。

#### 可变引用与不可变引用

```rust
let a = ...;
let mut b = ...;
```

a是不可变的，b是可变的， 可变引用只允许有一个引用，而不可变可以有多个引用指向它。
动动脑子都知道，对于可变引用，只有一个引用，这肯定不会因为并发而影响造成脏数据。
而不可变引用，因为他是不可变的，那的状态保持不变，你可以随便的使用它，毕竟没有副作用。

-------------------------------------------------------

rust在github上开源： [https://github.com/rust-lang/rust](https://github.com/rust-lang/rust)

关于rust的简短介绍是: A safe, concurrent, practical language.

#### 关于 concurrent.

std lib里面大量的blocking api，不过关于并发方便的利器，只提供了channel。协程、异步都要自己实现。
可能我了解rust的信息都太老了，也没有关注rust官方，可能rust官方新出了新的API。

#### 关于 practical

不得不面对的一个现实就是很多人在最开始是不适应rust的设计、语法的。确实，虽然自己是C语言程序员出身，
然后转向以Python+Javasc为主，加以爱好lisp，了解过各种小众语言，确实不适应rust。

--------------------------------------------------------

很多人说rust是为了编写高性能的系统程序，可是我看系统级别的程序还是得靠C语言。
rust最初由ocaml实现，但是ocaml目前还有百分之十左右的c实现代码，也就是说rust的实现离不开c语言。

#### 最后

至于我为什么会再次看一下rust，很大一部分原因在于rust的包管理——cargo。
可以自动生成binary和动态链接库，无需编写Makefile。这样子就省了很多事。

展望未来，我要使用rust编写一个中间件，然后在我的毕业设计中使用。
